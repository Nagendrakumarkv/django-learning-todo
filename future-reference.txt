Day 1 Goal: Create the project, set up the file structure, and define your database table (Model).

Follow these steps exactly in your terminal (Command Prompt/PowerShell or Terminal).

Step 1: The Setup
We need a clean room for your project so it doesn't interfere with other Python stuff on your computer.

Create a folder:
mkdir django_todo
cd django_todo

Create a Virtual Environment:
python -m venv venv
venv\Scripts\activate

(You should see (venv) appear at the start of your command line line. This means you are inside the isolated environment.)

Install Django:
pip install django

Step 2: Start the Engine
Now we generate the standard Django file structure.

Start the Project: (Note the . at the end. It prevents Django from creating an extra redundant folder).
django-admin startproject myproject .

Create the App: Django projects are made of "apps". We will call ours tasks.
python manage.py startapp tasks

Connect them (CRITICAL STEP): Django doesn't know the tasks app exists yet.
Open myproject/settings.py in your code editor.
Scroll down to the INSTALLED_APPS list
Add 'tasks', to the list.

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    # ... other defaults ...
    'tasks',  # <--- ADD THIS LINE
]

Step 3: Define the Data (The Model)
We need to tell the database what a "Task" looks like.

Open tasks/models.py.
Delete the code there and paste this:

from django.db import models

class Task(models.Model):
    title = models.CharField(max_length=200)
    description = models.TextField(blank=True, null=True)
    completed = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title

CharField: Small text (like a title).
TextField: Large text (like a description).
BooleanField: True/False (checkbox).
auto_now_add: Automatically saves the exact time you created the task.   

Step 4: Build the Database
Now we translate that Python code into a real Database (SQLite).

Make Migrations (Create the blueprint):
python manage.py makemigrations

You should see a message saying "Create model Task".

Migrate (Build the house):
python manage.py migrate

Step 5: Verify it works
Let's turn the lights on.

Run the server:
python manage.py runserver

Open your browser and go to http://127.0.0.1:8000/. You should see the little rocket ship that says "The install worked successfully! Congratulations!"

-------------------------------------------------------------------------------------------------------

Day 2 Goal: The "Read" Operation. We want to see our tasks in the Django Admin panel, and then on a public webpage.

Step 1: The Admin Panel
Django comes with a pre-built backend so you can manage your data immediately.

Create a Superuser (Admin): Run this in your terminal. It will ask for a username, email (you can skip this), and password (which won't show on screen as you type).
python manage.py createsuperuser

Register your Model: We need to tell the Admin panel that "Tasks" exist
Open tasks/admin.py.

Add this code:
from django.contrib import admin
from .models import Task

admin.site.register(Task)

Add Data:
Run the server: python manage.py runserver
Go to http://127.0.0.1:8000/admin/
Login with your superuser credentials.
Click on Tasks and add 2 or 3 tasks (e.g., "Buy Milk", "Learn Django").

Step 2: The View (The Logic)
Now let's pull that data from the database using Python code.

Open tasks/views.py.

We will create a "view function" that gets the data and sends it to a template.
from django.shortcuts import render
from .models import Task  # Import the model

def task_list(request):
    # 1. Fetch all tasks from the database
    tasks = Task.objects.all()

    # 2. Bundle them into a dictionary (context)
    context = {'tasks': tasks}

    # 3. Return the HTML page with the data inside
    return render(request, 'tasks/task_list.html', context)

Step 3: The Template (The Interface)
Django looks for HTML files in a specific folder structure. This part is specific, so be careful with the folders.

Inside your tasks folder, create a new folder named templates.
Inside templates, create another folder named tasks.
Inside that, create a file named task_list.html.
Structure should look like: tasks/templates/tasks/task_list.html
Paste this HTML into task_list.html:    

<!DOCTYPE html>
<html>
<head>
    <title>My Task Manager</title>
</head>
<body>
    <h1>My Tasks</h1>
    <hr>

    {% for task in tasks %}
        <div style="border-bottom: 1px solid #ccc; padding: 10px;">
            <h3>{{ task.title }}</h3> 
            <p>Status: {{ task.completed|yesno:"Done,Pending" }}</p>
            <p>Created: {{ task.created_at }}</p>
        </div>
    {% empty %}
        <p>No tasks found.</p>
    {% endfor %}

</body>
</html>

{% for %}: This is the Django Template Language. It loops through the list just like Python.
{{ variable }}: This outputs the data.

Step 4: The URL (The Map)
Finally, we need to tell Django: "When someone visits the homepage, show them the task_list view."

Open myproject/urls.py.

Modify the file to look like this:
from django.contrib import admin
from django.urls import path
from tasks.views import task_list  # Import your view

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', task_list, name='task_list'), # Empty string '' means the homepage
]

Step 5: Verify Day 2
Make sure your server is running (python manage.py runserver).

Go to http://127.0.0.1:8000/.

You should see your list of tasks displayed on the page!

If you see the tasks you added in Step 1, you have successfully connected the Database, the View, and the Template.

Are you seeing the list? 

-----------------------------------------------------------------------------------------------------

Excellent. Day 3 is where the app starts becoming interactive. We are moving from just reading data to creating data.

Day 3 Goal: The "Create" Operation. We will build a page where users can type in a task and save it to the database.

To do this, we need to handle two things:

GET Request: Show the user an empty form.

POST Request: Receive the data they typed, check if it's valid, and save it.

Step 1: The Form (The Magic Helper)
Django has a superpower called ModelForm. It looks at your Database Model and automatically builds an HTML form for it.

Create a new file tasks/forms.py.

Add this code:
from django import forms
from .models import Task

class TaskForm(forms.ModelForm):
    class Meta:
        model = Task
        fields = ['title', 'description', 'completed']
        # We don't need 'created_at' because that's automatic

Step 2: The View (The Logic)
We need a view that handles both showing the form and saving the data. This is a standard pattern in Django.

Open tasks/views.py.

Update your imports (add redirect and your TaskForm) and add the create_task function:
from django.shortcuts import render, redirect  # <--- Import redirect
from .models import Task
from .forms import TaskForm  # <--- Import your new Form

# ... keep your existing task_list view ...

def create_task(request):
    # 1. If the user clicked "Submit" (POST request)
    if request.method == 'POST':
        form = TaskForm(request.POST)
        if form.is_valid():
            form.save()  # Saves to the Database
            return redirect('task_list')  # Go back to the homepage

    # 2. If the user just visited the page (GET request)
    else:
        form = TaskForm() # Create an empty form

    # 3. Send the form (empty or with errors) to the template
    return render(request, 'tasks/task_form.html', {'form': form})

Step 3: The Template (The Interface)
Now we create the HTML page for the form.

Create a new file tasks/templates/tasks/task_form.html.

Add this code:
<!DOCTYPE html>
<html>
<head>
    <title>Add Task</title>
</head>
<body>
    <h1>Add a New Task</h1>

    <form method="POST">
        {% csrf_token %}  {{ form.as_p }}   <button type="submit">Save Task</button>
    </form>

    <a href="{% url 'task_list' %}">Cancel</a>
</body>
</html>

{% csrf_token %}: This is a security feature. Django will reject the form without it.

{{ form.as_p }}: This magically turns your Python form object into HTML input fields (<input>).

Step 4: The URL (The Map)
Open myproject/urls.py.

Import the new view and add the path:
from tasks.views import task_list, create_task # <--- Update imports

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', task_list, name='task_list'),
    path('create/', create_task, name='create_task'), # <--- Add this
]

Step 5: Connect the Pages
We have the page, but no way to get to it! Let's add a button to your homepage.

Open tasks/templates/tasks/task_list.html.

Add a link at the top, just under the <h1>:
<h1>My Tasks</h1>
<a href="{% url 'create_task' %}">+ Add New Task</a> <hr>

Step 6: Verify Day 3
Run the server (python manage.py runserver).

Go to the homepage. Click "+ Add New Task".

Fill out the form and click "Save Task".

It should redirect you back to the list, and your new task should be there!

Did it save? If so, you have conquered the "C" in CRUD! Ready for Day 4 (Updating and Deleting)?

----------------------------------------------------------------------------------------------------

You are flying through this! Day 4 is powerful because it completes the cycle.

Day 4 Goal: The "Update" and "Delete" Operations. We need to give users the ability to fix mistakes (Edit) or remove completed items (Delete).

To do this, we need Dynamic URLs. We can't just go to /update/. We need to go to /update/1/ or /update/5/, where the number is the specific ID (Primary Key) of the task.

Step 1: The URLs (Dynamic Paths)
We need to tell Django to expect a number in the URL.

Open myproject/urls.py.

Import the new views (we will create them next) and add the paths with <int:pk>.

int: means "integer" (number).

pk: means "primary key" (ID).
from tasks.views import task_list, create_task, update_task, delete_task  # <--- Update imports

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', task_list, name='task_list'),
    path('create/', create_task, name='create_task'),
    path('update/<int:pk>/', update_task, name='update_task'), # <--- Dynamic ID
    path('delete/<int:pk>/', delete_task, name='delete_task'), # <--- Dynamic ID
]

Step 2: The Views (Logic)
Open tasks/views.py.

Add these two functions at the bottom.

The Update View: This is 90% identical to create_task. The only difference is we fetch the specific task first and pass it into the form as instance=task. This tells Django: "Pre-fill the form with this data."

def update_task(request, pk):
    task = Task.objects.get(id=pk)  # 1. Fetch the specific task by ID

    if request.method == 'POST':
        form = TaskForm(request.POST, instance=task) # 2. Bind data to this task
        if form.is_valid():
            form.save()
            return redirect('task_list')
    else:
        form = TaskForm(instance=task) # 3. Pre-fill form with existing data

    return render(request, 'tasks/task_form.html', {'form': form}) 
    # Note: We reuse the same template as Create!

The Delete View: We never delete immediately on a click (that's dangerous). We show a confirmation page first.

def delete_task(request, pk):
    task = Task.objects.get(id=pk)

    if request.method == 'POST':
        task.delete()  # <--- The actual delete command
        return redirect('task_list')

    return render(request, 'tasks/task_delete.html', {'task': task})

Step 3: The Delete Template
We are reusing the task_form.html for updating, but we need a new specific page for deleting.

Create tasks/templates/tasks/task_delete.html.

Add this code:

<!DOCTYPE html>
<html>
<head>
    <title>Delete Task</title>
</head>
<body>
    <h1>Delete Task</h1>
    <p>Are you sure you want to delete "{{ task.title }}"?</p>

    <form method="POST">
        {% csrf_token %}
        <button type="submit">Yes, Delete</button>
        <a href="{% url 'task_list' %}">Cancel</a>
    </form>
</body>
</html>

Step 4: Add Buttons to the List
Now we go back to our main list and add the "Edit" and "Delete" buttons next to every task.

Open tasks/templates/tasks/task_list.html.

Update the loop to include the links. Notice how we pass task.id into the URL tag.

{% for task in tasks %}
    <div style="border-bottom: 1px solid #ccc; padding: 10px;">
        <h3>{{ task.title }}</h3>
        <p>Status: {{ task.completed|yesno:"Done,Pending" }}</p>

        <a href="{% url 'update_task' task.id %}">Edit</a>

        <a href="{% url 'delete_task' task.id %}" style="color: red; margin-left: 10px;">Delete</a>
    </div>
{% empty %}
    <p>No tasks found.</p>
{% endfor %}

Step 5: Verify Day 4
Refresh your homepage.

Test Update: Click "Edit" on a task. Change the title or check the "Completed" box. Save. Does it change on the list?

Test Delete: Click "Delete". You should see the "Are you sure?" page. Click "Yes". It should vanish.

Congratulations! You have built a fully functional CRUD application.

Create (Day 3)

Read (Day 2)

Update (Day 4)

Delete (Day 4)

Tomorrow is the victory lap. We will add Bootstrap to make it look professional (Day 5).

Does everything work so far?

----------------------------------------------------------------------------------------------------

This is the victory lap! Today we take your functional but plain application and make it look professional using Bootstrap.

Day 5 Goal: Implement Template Inheritance and apply Bootstrap CSS.

Currently, every HTML file you have repeats the same structure (<html>, <head>, <body>). If you wanted to add a Navbar to every page, you’d have to edit all three files.

We will fix this using a Base Template.

Step 1: Create the Base Template
This file will hold the "skeleton" of your site (Navbar, Footer, CSS links). All other pages will inject their content into it.

Create a new file: tasks/templates/tasks/base.html.

Paste this code (includes Bootstrap 5 via CDN):

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Task Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light">

    <nav class="navbar navbar-dark bg-primary mb-4">
        <div class="container">
            <a class="navbar-brand" href="{% url 'task_list' %}">✅ TaskManager</a>
        </div>
    </nav>

    <div class="container">
        {% block content %}
        {% endblock %}
    </div>

</body>
</html>

Step 2: Style the List Page
Now we modify task_list.html to "extend" the base template. We will also replace the ugly list with a nice Bootstrap Card layout.

Open tasks/templates/tasks/task_list.html.

Delete everything in that file and replace it with this:

{% extends 'tasks/base.html' %}

{% block content %}
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h1>My Tasks</h1>
        <a href="{% url 'create_task' %}" class="btn btn-success">+ Add Task</a>
    </div>

    <div class="row">
        {% for task in tasks %}
            <div class="col-md-6 col-lg-4 mb-3">
                <div class="card shadow-sm h-100">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-start">
                            <h5 class="card-title">{{ task.title }}</h5>
                            {% if task.completed %}
                                <span class="badge bg-success">Done</span>
                            {% else %}
                                <span class="badge bg-warning text-dark">Pending</span>
                            {% endif %}
                        </div>

                        <p class="card-text text-muted">{{ task.description|truncatewords:10 }}</p>

                        <div class="mt-3">
                            <a href="{% url 'update_task' task.id %}" class="btn btn-sm btn-outline-primary">Edit</a>
                            <a href="{% url 'delete_task' task.id %}" class="btn btn-sm btn-outline-danger">Delete</a>
                        </div>
                    </div>
                </div>
            </div>
        {% empty %}
            <div class="alert alert-info">No tasks found. Create one above!</div>
        {% endfor %}
    </div>
{% endblock %}

Step 3: Style the Forms
We use the same logic for the create/update page. We will use a library called django-widget-tweaks later in your career, but for now, we will wrap the form in a nice card.

Open tasks/templates/tasks/task_form.html.

Replace everything with:

{% extends 'tasks/base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <div class="card">
            <div class="card-header bg-primary text-white">
                <h4 class="mb-0">Task Details</h4>
            </div>
            <div class="card-body">
                <form method="POST">
                    {% csrf_token %}
                    {% for field in form %}
                        <div class="mb-3">
                            <label class="form-label">{{ field.label }}</label>
                            {{ field }} </div>
                    {% endfor %}

                    <div class="d-grid gap-2">
                        <button type="submit" class="btn btn-success">Save Task</button>
                        <a href="{% url 'task_list' %}" class="btn btn-secondary">Cancel</a>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>
{% endblock %}

Step 4: Style the Delete Page
Open tasks/templates/tasks/task_delete.html.

Replace everything with:

{% extends 'tasks/base.html' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-6">
        <div class="alert alert-danger text-center">
            <h3>Are you sure?</h3>
            <p>You are about to delete <strong>"{{ task.title }}"</strong>.</p>

            <form method="POST">
                {% csrf_token %}
                <button type="submit" class="btn btn-danger">Yes, Delete</button>
                <a href="{% url 'task_list' %}" class="btn btn-secondary">Cancel</a>
            </form>
        </div>
    </div>
</div>
{% endblock %}

Step 5: Final Verification
Run your server: python manage.py runserver.

Refresh your browser.

What you should see:

A blue Navbar at the top.

Tasks displayed as "Cards" in a grid layout.

Green/Yellow badges showing status.

Clean, centered forms when you Edit or Delete.

Congratulations!
You have built a Full Stack Web Application in 5 days.

Backend: Python & Django (Models, Views, URLs).

Database: SQLite (managed via ORM).

Frontend: HTML, Django Templates, and Bootstrap CSS.

Where to go from here? You have the core skills. The next logical step is usually User Authentication (allowing users to sign up and login so they only see their tasks).

Would you like a bonus "Day 6" guide on adding Login/Register functionality, or are you happy to wrap up here?

